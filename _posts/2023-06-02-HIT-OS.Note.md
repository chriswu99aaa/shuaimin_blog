## 操作系统初始化

在最开始的两讲中，学习操作系统怎样启动。

* bootsect.s：将操作系统从磁盘读进内存
* setup.s：：获得了一些参数启动了保护模式，从16进制变成32进制的汇编语言
* head.s：初始化一些列的 管理内存的GTD 表格
* main.c
* mem_init

计算机cpu会在硬板0x90000 处读取操作系统。计算机从最开始的黑屏，一步步读取更多的信息，讲所需要的参数在setup.s 中初始化，然后将管理内存的表格初始化。最终操作系统将会以一个不停止的进程的方式不断运行直到收到结束的指令

## 操作系统接口

操作系统提供了很多重要的函数，它们就是操作系统接口。我们就可以很主观的调用操作系统资源

### 用户如何使用计算机

1. 命令行
2. 图形按钮
3. 应用程序

#### 命令行是怎么回事
'''C
#include <stdio.h>
int main(int argc, char * argv[])
{
printf("ECHO: %s\n", argv[1];)
}
'''

'''C
int main(int argc, char* argv[])
{
  char cmd[20]
  while(1)
  {
      scanf("%s", cmd)
      if(!fork()) # child process
      {
        exec(cmd);
      }else{
      waits();
      }
  }
}
'''

fork() and exec()对cpu 进行调用，printf()对显示器进行调用，scanf（）对键盘进行调用。

### 图形按钮是怎么回事

它的实现基于消息处理函数，要有一个函数不断地从cpu 上获取消息，然后执行对应的函数。
图形界面： 消息框架程序+消息处理程序

### 系统调用

POSIX: Portable Operating System Interface

|---分类|POSIX定义|描述|
|-------|---------|----|
|任务管理|fork|创建一个进程|
|任务管理|excel|运行一个可执行程序|
|任务管理|pthread_create|创建一个进程|
|文件系统|open|打开一个文件或目录|
|文件系统|EACCES|返回值|
|文件系统|mode_tst_mode|文件头结构：文件属性|

### 系统调用的直观实现

实现一个whoami 系统调用

* 不能随意调用数据，不能随意jmp
* 都在内存中，但不能随意进入

三个问题
1. 不能jmp
2. 凭什么不能jmp
3. 不jmp 怎么实现调用

#### 内核态/用户态，内核段/用户段

特权级别：
* 0 内核态
* 1-2 OS 态
* 3 用户态
0最高，3最低
内核态可以访问任何数据，用户态不能访问内核数据

CPL（Current Privilege Level）当前特权等级
DPL（Destination Privilege Level）目标特权等级
只有当 DPL》CPL 或 DPL 》RPL。只有目标特权级高于当前特权级才能访问

#### 中断指令int

系统调用的核心
1. 用户程序中包含一段 int 指令的代码
2. 操作系统写中断处理，获取想调程序的编号
3. 操作系统根据编号执行相应代码
int 0x80 中断指令

一段系统中断_syscall3的内嵌宏代码，包含int 0x80 表示进入内核，同时将 __NR_##name 传到 eax

1. 用户调用 printf
2. printf 展开到 int 0x80
3. system_call 中断处理
4. system_call_table 查表
5. __NR_write = 4
6. sys_write 调用

前两项是用户态，后四项是内核态

问题：
1. printf 后面一系列调用的细节。是否可以找一些材料阅读
2. system_call 是怎样实现的。

用户通过 system_call 系统调用， 也就是int 0x80 中断从用户态进入内核态

### 操作系统历史

核心思想：
* 程序执行，多线程，程序执行带动其他设备使用的结构
* 更加重视用户使用体验

软件实现：
* 如何通过文件存储代码，执行代码，操作屏幕
* 如何让文件和操作变成图标，点击

任务:

1. 掌握，实现操作系统的多进程图谱
2. 掌握，实现操作系统的文件操作视图

操作系统启动
```c
void main(void)
{
  mem_init();
  trap_init();
  ...
  sched_init();
  buffer_init();
  hd_init();
  floppy_init();
  sti();
  move_to_user_mode();
  if(!fork())
  {
    init();
  }
}
```

## 多进程图像

多进程的组织按照：PCB + 状态 + 队列

![image]('../pictures/multi_process.png')

进程的调度，是将目前进程的信息，转移到一边，然后cpu 读取下一个进程的pcb，然后执行。

多进程的一个核心是内存管理。这其中有虚拟内存的概念。它让每个进程仿佛在全部使用cpu和内存，而实际上一个进程只是在占用内存的一部分。


## 用户级线程

线程是在进程里面的 

线程保留了并发的优点，避免了进程的切换代价。

进程的切换，涉及到指令的切换，以及内存的切换 

每一个线程都有自己的栈，这让线程的切换变得更加简单。当每次

```c
void Yield(){
TCB2.esp = esp;
esp = TCB1.esp;
}
```
TCB(thread control block) 和 栈 的配合。切栈之前，把当前的栈存进TCB，这就可以让线程切换返回到原来的指令。





