## 操作系统初始化

在最开始的两讲中，学习操作系统怎样启动。

* bootsect.s：将操作系统从磁盘读进内存
* setup.s：：获得了一些参数启动了保护模式，从16进制变成32进制的汇编语言
* head.s：初始化一些列的 管理内存的GTD 表格
* main.c
* mem_init

计算机cpu会在硬板0x90000 处读取操作系统。计算机从最开始的黑屏，一步步读取更多的信息，讲所需要的参数在setup.s 中初始化，然后将管理内存的表格初始化。最终操作系统将会以一个不停止的进程的方式不断运行直到收到结束的指令

## 操作系统接口

操作系统提供了很多重要的函数，它们就是操作系统接口。我们就可以很主观的调用操作系统资源

### 用户如何使用计算机

1. 命令行
2. 图形按钮
3. 应用程序

#### 命令行是怎么回事
'''C
#include <stdio.h>
int main(int argc, char * argv[])
{
printf("ECHO: %s\n", argv[1];)
}
'''

'''C
int main(int argc, char* argv[])
{
  char cmd[20]
  while(1)
  {
      scanf("%s", cmd)
      if(!fork()) # child process
      {
        exec(cmd);
      }else{
      waits();
      }
  }
}
'''

fork() and exec()对cpu 进行调用，printf()对显示器进行调用，scanf（）对键盘进行调用。

### 图形按钮是怎么回事

它的实现基于消息处理函数，要有一个函数不断地从cpu 上获取消息，然后执行对应的函数。
图形界面： 消息框架程序+消息处理程序

### 系统调用

POSIX: Portable Operating System Interface

|---分类|POSIX定义|描述|
|-------|---------|----|
|任务管理|fork|创建一个进程|
|任务管理|excel|运行一个可执行程序|
|任务管理|pthread_create|创建一个进程|
|文件系统|open|打开一个文件或目录|
|文件系统|EACCES|返回值|
|文件系统|mode_tst_mode|文件头结构：文件属性|

### 系统调用的直观实现

实现一个whoami 系统调用

* 不能随意调用数据，不能随意jmp
* 都在内存中，但不能随意进入

三个问题
1. 不能jmp
2. 凭什么不能jmp
3. 不jmp 怎么实现调用

#### 内核态/用户态，内核段/用户段

特权级别：
* 0 内核态
* 1-2 OS 态
* 3 用户态
0最高，3最低
内核态可以访问任何数据，用户态不能访问内核数据

CPL（Current Privilege Level）当前特权等级
DPL（Destination Privilege Level）目标特权等级
只有当 DPL》CPL 或 DPL 》RPL。只有目标特权级高于当前特权级才能访问

#### 中断指令int

系统调用的核心
1. 用户程序中包含一段 int 指令的代码
2. 操作系统写中断处理，获取想调程序的编号
3. 操作系统根据编号执行相应代码
int 0x80 中断指令

一段系统中断_syscall3的内嵌宏代码，包含int 0x80 表示进入内核，同时将 __NR_##name 传到 eax

1. 用户调用 printf
2. printf 展开到 int 0x80
3. system_call 中断处理
4. system_call_table 查表
5. __NR_write = 4
6. sys_write 调用

前两项是用户态，后四项是内核态

问题：
1. printf 后面一系列调用的细节。是否可以找一些材料阅读
2. system_call 是怎样实现的。

用户通过 system_call 系统调用， 也就是int 0x80 中断从用户态进入内核态




















